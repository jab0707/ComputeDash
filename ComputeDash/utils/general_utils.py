import ComputeDash.utils.globalParams as gp
import json, os
import numpy as np

def readLogFile(logFile,pop=False):
	with open(logFile) as f:
		stats = json.load(f)
	if pop:
		os.remove(logFile)
	return stats
def updateLogFile(logFile,logData,clean=False):
	if os.path.isfile(logFile) and not clean:
		oldLog = readLogFile(logFile)
		for key in logData.keys():
			logData[key].extend(oldLog[key])
	with open(logFile, "w") as f:#if clean is true, will overwrite to make a fresh log file
		json.dump(logData, f)



def infoDump(message,priority=-1):
	if priority < gp.VERBOCITY:
		print(message)

def readLogHistory(file):
	return np.load(file)

def writeLogHistory(file,logDict):
	existingData = None#CPU, MEMORY, DISK, GPU, time
	if os.path.isfile(file):
		existingData = readLogHistory(file)
	dataToAdd = [[logDict['cpu']],
				[logDict['memory']],
				[logDict['disk']],
				[len(logDict['gpu'])]]
	gpuIds = [[g['id']] for g in logDict['gpu']]
	gpuLoads = [[g['load']] for g in logDict['gpu']]
	dataToAdd.extend(gpuIds)
	dataToAdd.extend(gpuLoads)
	dataToAdd.extend([[logDict['time']]])
	print(f'dataToAdd:\n{dataToAdd}')
	newData = np.array(dataToAdd)
	print(f'NewData shape: {newData.shape}')
	if existingData is not None:
		newData = np.concatenate((existingData,newData),axis=1)
	np.save(file,newData)




def argListToDict(argList):
	argDict = {}
	keys = [val for val in argList if '--' in val]#keys have --
	vals = []
	if len(keys)>0:
		for kIx in range(len(keys)-1): #need to account for possible list arguments
			startIx = argList.index(keys[kIx]) + 1
			endIx = argList.index(keys[kIx+1])
			currentVal = argList[startIx:endIx]
			if len(currentVal) == 1:
				currentVal = currentVal[0]
			vals.append(currentVal)
		vals.append(argList[argList.index(keys[-1])+1:])

		#Clean up the formatting a bit
		keys = [k.replace('--','') for k in keys]
		argDict.update(dict(zip(keys,vals)))#convert them into a dictionary
	return argDict


def removeUneededArgs(argDict,parser):
	'''
	This function removes arguments generated by the given parser so they do not
	Cause errors when they get passed to downstream scripts which do not expect those args
	'''
	parserMe= parser()
	removals = parserMe._option_string_actions.keys()#Get the specific keys for this parser
	for removeKey in removals:#remove those keys from the input argument dictionary
		removeKey = removeKey.replace('--','')
		if removeKey in argDict.keys():
			#print(f'removing {removeKey}')
			argDict.pop(removeKey)
	return argDict

def dictToArgList(argDict):
	'''
	This function converts a dictionary of arguments into a list with 
	every other entry (starting at 0) being a command line 
	key of the form --key and every other entry (starting at 1)
	being a value for that key
	'''
	argList = []
	for key in argDict.keys():
		value = argDict[key]
		if value is not None:
			newArg = [f'--{key}']
			if type(value) == list:
				for val in value:
					newArg.extend([str(val)])
			else:
				newArg.extend([str(value)])
			argList.extend(newArg)
	return argList
import ComputeDash.utils.globalParams as gp
import json, os, psutil, GPUtil, time,sys,datetime
import numpy as np

def scrape_data():
	stats = {
		"cpu":[psutil.cpu_percent(interval=1)],
		"memory": [psutil.virtual_memory().percent],
        "disk": [psutil.disk_usage('/').percent],
        "gpu": [[{"id": gpu.id, "load": gpu.load * 100} for gpu in GPUtil.getGPUs()]],
        "time":[datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")]
	}
	return stats

def readLogFile(logFile,pop=False):
	with open(logFile) as f:
		stats = json.load(f)
	if pop:
		os.remove(logFile)
	return stats
def updateLogFile(logFile,logData,clean=False):
	if os.path.isfile(logFile) and not clean:
		oldLog = readLogFile(logFile)
		for key in logData.keys():
			logData[key].extend(oldLog[key])
	with open(logFile, "w") as f:#if clean is true, will overwrite to make a fresh log file
		json.dump(logData, f)



def infoDump(message,priority=-1):
	if priority < gp.VERBOCITY:
		print(message)

def readLogHistory(file):
	return np.load(file)

def writeLogHistory(file,logDict):
	existingData = None#CPU, MEMORY, DISK, GPU, time
	if os.path.isfile(file):
		existingData = readLogHistory(file)
	dataToAdd = [logDict['cpu'],
				logDict['memory'],
				logDict['disk']]
	gpuIds = [g['id'] for g in logDict['gpu'][0]]
	gpuLoads = [[] for _ in gpuIds]
			
	for log in logDict['gpu']:

		for gpuIx in range(len(gpuIds)):
			gpuLoads[gpuIx].extend([log[gpuIx]['load']])
	for gpuId in gpuIds:
		dataToAdd.extend([[gpuId for _ in range(len(logDict['gpu'])) ]])
	dataToAdd.extend(gpuLoads)
	dataToAdd.extend([logDict['time']])
	print(f'dataToAdd:')
	[print(f'{d}\n') for d in dataToAdd]
	newData = np.array(dataToAdd)
	print(f'NewData shape: {newData.shape}')
	if existingData is not None:
		newData = np.concatenate((existingData,newData),axis=1)
	np.save(file,newData)




def argListToDict(argList):
	argDict = {}
	keys = [val for val in argList if '--' in val]#keys have --
	vals = []
	if len(keys)>0:
		for kIx in range(len(keys)-1): #need to account for possible list arguments
			startIx = argList.index(keys[kIx]) + 1
			endIx = argList.index(keys[kIx+1])
			currentVal = argList[startIx:endIx]
			if len(currentVal) == 1:
				currentVal = currentVal[0]
			vals.append(currentVal)
		vals.append(argList[argList.index(keys[-1])+1:])

		#Clean up the formatting a bit
		keys = [k.replace('--','') for k in keys]
		argDict.update(dict(zip(keys,vals)))#convert them into a dictionary
	return argDict


def removeUneededArgs(argDict,parser):
	'''
	This function removes arguments generated by the given parser so they do not
	Cause errors when they get passed to downstream scripts which do not expect those args
	'''
	parserMe= parser()
	removals = parserMe._option_string_actions.keys()#Get the specific keys for this parser
	for removeKey in removals:#remove those keys from the input argument dictionary
		removeKey = removeKey.replace('--','')
		if removeKey in argDict.keys():
			#print(f'removing {removeKey}')
			argDict.pop(removeKey)
	return argDict

def dictToArgList(argDict):
	'''
	This function converts a dictionary of arguments into a list with 
	every other entry (starting at 0) being a command line 
	key of the form --key and every other entry (starting at 1)
	being a value for that key
	'''
	argList = []
	for key in argDict.keys():
		value = argDict[key]
		if value is not None:
			newArg = [f'--{key}']
			if type(value) == list:
				for val in value:
					newArg.extend([str(val)])
			else:
				newArg.extend([str(value)])
			argList.extend(newArg)
	return argList